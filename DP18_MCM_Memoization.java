
/*
 * MCM --> It Stands For Matrix Chain Multiplication...... 
 * In An Multiplication Of Matrix A[a X b] & Matrix B[c X d] , Then : -
    ~> For Mult. , b=c Is Nessecarry Condition.....
    ~> The Order Of 'AXB' Will Be [a X d].....
    ~> The Total Operations Will Be = (a*b*d) --> Treat This As Cost Of Multiplication.......

 * We Will Be Given n-Matrixes And We Have To Perform Multiplication Of These n-Matix In Such
    a Way Such That The Cost Of Multiplication Is Minimum.......
 * arr[]={1,2,3,4,3} Represents 4 Matrix ::: A(1X2) , B(2X3) , C(3X4) & D(4X3)....... 
 * Order Of Matrix-(i) --> arr[i-1] X arr[i] (Think About It)......
    ~> Matrix-i = arr[i-1] * arr[i]......
    ~> Matrix-j = arr[j-1] * arr[j]......
    ~> Matrix-k = arr[k-1] * arr[k]......
    
 * For A Series Of Multiplication From Matrix-(i) To Matrix-(k) , Then , The Final Order Of Product Of These
    Matrixes Will Be Row(i)*Col(k) i.e. (arr[i-1]*arr[k]) -> Order Of MCM From Matrix-(i) To Matrix-(j)......
*/
import java.util.*;

public class DP18_MCM_Memoization {

    public static int MCM_DP_Mem(int arr[], int Start, int End, int DP_Mem[][]) { // O(n^2).......
        if (Start == End) { // Mult. Of Single Matrix Is Not Possible......
            return 0;
        }
        if (DP_Mem[Start][End] != (-1)) {
            return DP_Mem[Start][End];
        }
        int MinCost = Integer.MAX_VALUE;
        for (int k = Start; k <= End - 1; k++) {

            // Cost Of Mult. From Matrix-(Start) To Matrix-(k).......
            // Order Of This Will Be Row(Start)*Col(k) --> arr[Start-1]*arr[k].......
            // This Will From Matrix-1 Of Order [arr[Start-1]*arr[k]]......
            int Cost1 = MCM_DP_Mem(arr, Start, k, DP_Mem);

            // Cost Of Mult. From Matrix-(k+1) To Matrix-(End).......
            // Order Of This Will Be Row(k+1)*Col(End) --> arr[k]*arr[End].......
            // This Will From Matrix-2 Of Order [arr[k]*arr[End]]......
            int Cost2 = MCM_DP_Mem(arr, k + 1, End, DP_Mem);

            // Mult. Of Matrix-1 & Matrix-2 Whose Cost Will Be Row(1)*Col(1)*Col(2)......
            // Cost Will Be [arr[Start-1] * arr[k] * arr[End]]......
            int Cost3 = arr[Start - 1] * arr[k] * arr[End];

            int FinalCost = Cost1 + Cost2 + Cost3;
            MinCost = Math.min(MinCost, FinalCost);
            DP_Mem[Start][End] = MinCost;
        }
        return MinCost;
    }

    public static void main(String args[]) {
        int arr[] = { 1, 2, 3, 4, 3 };
        int n = arr.length;
        int DP_Mem[][] = new int[n][n];
        for (int i = 0; i < n; i++) { // Initialize Each Element By (-1)......
            Arrays.fill(DP_Mem[i], -1);
        }
        int ans = MCM_DP_Mem(arr, 1, n - 1, DP_Mem);
        System.out.println("THE MIN. COST OF MCM USING DP WITH Memoization IS ::: " + ans);
    }
}
